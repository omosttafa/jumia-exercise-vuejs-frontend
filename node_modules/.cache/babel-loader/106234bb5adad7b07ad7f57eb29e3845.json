{"remainingRequest":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\babel-loader\\lib\\index.js!O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\vue-mdbootstrap\\src\\components\\BsGrid\\BsTreegridItems.vue?vue&type=script&lang=js&","dependencies":[{"path":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\vue-mdbootstrap\\src\\components\\BsGrid\\BsTreegridItems.vue","mtime":1609323834000},{"path":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIk86L1dPUksvSlVNSUEvdnVlanMvbmV3L2p1bWlhLXZ1ZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlci5qcyI7Ci8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCgovKioNCiAqIFRyZWVOb2RlIGRhdGEgdHlwZS4NCiAqDQogKiBAdHlwZWRlZiB7T2JqZWN0fSBJVHJlZU5vZGUNCiAqIEBwcm9wZXJ0eSB7QnNNb2RlbHxPYmplY3R9IGRhdGEgVGhlIE5vZGUncyBkYXRhIG1vZGVsDQogKiBAcHJvcGVydHkge251bWJlcn0gZGVwdGggICAgICAgIFRoZSBOb2RlJ3MgZGVwdGggbGV2ZWwgaW4gdGhlIFRyZWVMaXN0DQogKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggICAgICAgIFRoZSBOb2RlJ3MgYWJzb2x1dGUgaW5kZXggcG9zaXRpb24gaW4gdGhlIEFycmF5TGlzdA0KICogQHByb3BlcnR5IHtJVHJlZU5vZGV9IHBhcmVudCAgICBUaGUgcGFyZW50IG9mIHRoaXMgTm9kZQ0KICogQHByb3BlcnR5IHtib29sZWFufSBsZWFmICAgICAgICBUaGUgTm9kZSdzIGZsYWcsIGRlc2NyaWJlIGl0IGlzIHRoZSBsYXN0IGNoaWxkIGluIHRoZSBUcmVlTGlzdCBvciBub3QNCiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXhwYW5kZWQgICAgVGhlIE5vZGUncyBzdGF0ZSwgZXhwYW5kZWQgb3IgY29sbGFwc2VkDQogKi8KaW1wb3J0IEJzVHJlZVN0b3JlIGZyb20gIi4uLy4uL21vZGVsL0JzVHJlZVN0b3JlIjsKaW1wb3J0IEJzVHJlZWdyaWRDZWxsIGZyb20gIi4vQnNUcmVlZ3JpZENlbGwiOwppbXBvcnQgQnNHcmlkQ2VsbCBmcm9tICIuL0JzR3JpZENlbGwiOwppbXBvcnQgQ29tbW9uIGZyb20gIi4uLy4uL21peGlucy9Db21tb24iOwppbXBvcnQgSGVscGVyIGZyb20gIi4uLy4uL3V0aWxzL0hlbHBlciI7CmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAiQnNUcmVlZ3JpZEl0ZW1zIiwKICBjb21wb25lbnRzOiB7CiAgICBCc1RyZWVncmlkQ2VsbDogQnNUcmVlZ3JpZENlbGwsCiAgICBCc0dyaWRDZWxsOiBCc0dyaWRDZWxsCiAgfSwKICBtaXhpbnM6IFtDb21tb25dLAogIGluamVjdDogWydUcmVlR3JpZCddLAogIHByb3BzOiB7CiAgICBjb2x1bW5zOiB7CiAgICAgIHR5cGU6IEFycmF5LAogICAgICBkZWZhdWx0OiB1bmRlZmluZWQKICAgIH0sCiAgICBpdGVtczogewogICAgICB0eXBlOiBBcnJheSwKICAgICAgZGVmYXVsdDogdW5kZWZpbmVkCiAgICB9CiAgfSwKICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgY2hpbGRyZW5GaWVsZG1hcDogJycsCiAgICAgIHRyZWVOb2RlczogW10KICAgIH07CiAgfSwKICBjb21wdXRlZDogewogICAgdmlzaWJsZUl0ZW1zOiBmdW5jdGlvbiB2aXNpYmxlSXRlbXMoKSB7CiAgICAgIHJldHVybiB0aGlzLnRyZWVOb2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICByZXR1cm4gbm9kZS5kZXB0aCA9PT0gMCB8fCBub2RlLmV4cGFuZGVkIHx8IG5vZGUucGFyZW50LmV4cGFuZGVkOwogICAgICB9KTsKICAgIH0KICB9LAogIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7CiAgICB0aGlzLnRyZWVOb2RlcyA9IFtdOwogICAgdGhpcy5jaGlsZHJlbkZpZWxkbWFwID0gdGhpcy5UcmVlR3JpZC5jaGlsZHJlbkZpZWxkbWFwOwogIH0sCiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHsKICAgIHRoaXMudHJlZU5vZGVzID0gbnVsbDsKICB9LAogIG1ldGhvZHM6IHsKICAgIC8qKg0KICAgICAqIEdldCBjb21wb25lbnQncyBuYW1lIGF0IHRoZSBnaXZlbiBpbmRleC4NCiAgICAgKg0KICAgICAqIEBwYXJhbSB7aW50fSBjb2x1bW5JbmRleCBDb2x1bW4gaW5kZXggcG9zaXRpb24NCiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tcG9uZW50J3MgbmFtZQ0KICAgICAqIEBwcml2YXRlDQogICAgICovCiAgICBfY29tcG9uZW50TmFtZTogZnVuY3Rpb24gX2NvbXBvbmVudE5hbWUoY29sdW1uSW5kZXgpIHsKICAgICAgcmV0dXJuIGNvbHVtbkluZGV4ID09PSAwID8gJ2JzLXRyZWVncmlkLWNlbGwnIDogJ2JzLWdyaWQtY2VsbCc7CiAgICB9LAoKICAgIC8qKg0KICAgICAqIEdldCByb3cgY3NzIGNsYXNzIGF0IHRoZSBnaXZlbiBpbmRleC4NCiAgICAgKg0KICAgICAqIEBwYXJhbSB7aW50fSBpbmRleCBBYnNvbHV0ZSBpbmRleCBwb3NpdGlvbg0KICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQ3NzIGNsYXNzZXMNCiAgICAgKiBAcHJpdmF0ZQ0KICAgICAqLwogICAgX3Jvd0NsYXNzZXM6IGZ1bmN0aW9uIF9yb3dDbGFzc2VzKGluZGV4KSB7CiAgICAgIHJldHVybiBbaW5kZXggJSAyID09PSAwID8gJ21kLWdyaWQtcm93JyA6ICdtZC1ncmlkLXJvdy1hbHQnXTsKICAgIH0sCgogICAgLyoqDQogICAgICogQXBwZW5kIGNoaWxkbm9kZXMgdG8gdGhlIHRyZWVpdGVtcy4NCiAgICAgKg0KICAgICAqIEBwYXJhbSB7SVRyZWVOb2RlfSBwYXJlbnROb2RlICAgICBQYXJlbnQgbm9kZQ0KICAgICAqIEBwYXJhbSB7QnNNb2RlbFtdfE9iamVjdFtdfSBkYXRhcyBDb2xsZWN0aW9uIG9mIGRhdGEgbW9kZWwNCiAgICAgKiBAcmV0dXJucyB7dm9pZH0NCiAgICAgKiBAcHJpdmF0ZQ0KICAgICAqLwogICAgX2FwcGVuZENoaWxkOiBmdW5jdGlvbiBfYXBwZW5kQ2hpbGQocGFyZW50Tm9kZSwgZGF0YXMpIHsKICAgICAgdmFyIHRtcE5vZGVzID0gW107CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHJlZU5vZGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnRyZWVOb2Rlc1tpXTsKICAgICAgICB0bXBOb2Rlcy5wdXNoKG5vZGUpOwoKICAgICAgICBpZiAobm9kZSA9PT0gcGFyZW50Tm9kZSkgewogICAgICAgICAgdmFyIHJvd0luZGV4ID0gaSArIDE7CgogICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGFzKSwKICAgICAgICAgICAgICBfc3RlcDsKCiAgICAgICAgICB0cnkgewogICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykgewogICAgICAgICAgICAgIHZhciBkYXRhID0gX3N0ZXAudmFsdWU7CgogICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSB0aGlzLl9jcmVhdGVOb2RlKGRhdGEsIHBhcmVudE5vZGUsIHBhcmVudE5vZGUuZGVwdGggKyAxLCByb3dJbmRleCwgZmFsc2UpOwoKICAgICAgICAgICAgICB0bXBOb2Rlcy5wdXNoKGNoaWxkTm9kZSk7CiAgICAgICAgICAgICAgcm93SW5kZXgrKzsKICAgICAgICAgICAgfQogICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgbm9kZS5pbmRleCA9IGk7CiAgICAgIH0KCiAgICAgIHRoaXMudHJlZU5vZGVzID0gdG1wTm9kZXM7CiAgICB9LAoKICAgIC8qKg0KICAgICAqIENyZWF0ZSBJVHJlZU5vZGUgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBtb2RlbC4NCiAgICAgKg0KICAgICAqIEBwYXJhbSB7QnNNb2RlbHxPYmplY3R9IGRhdGEgICBEYXRhIG1vZGVsDQogICAgICogQHBhcmFtIHtJVHJlZU5vZGV9IHBhcmVudE5vZGUgIFBhcmVudCBub2RlDQogICAgICogQHBhcmFtIHtpbnR9IGRlcHRoICAgICAgICAgICAgIE5vZGUgZGVwdGggbGV2ZWwgd2l0aGluIHRoZSBUcmVlTGlzdA0KICAgICAqIEBwYXJhbSB7aW50fSBpbmRleCAgICAgICAgICAgICBBYnNvbHV0ZSBub2RlIGluZGV4IHBvc2l0aW9uIHdpdGhpbiB0aGUgVHJlZUxpc3QNCiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV4cGFuZGVkICAgICAgVGhlIG5vZGUgc3RhdGUNCiAgICAgKiBAcmV0dXJucyB7SVRyZWVOb2RlfSBUaGUgdHJlZU5vZGUNCiAgICAgKiBAcHJpdmF0ZQ0KICAgICAqLwogICAgX2NyZWF0ZU5vZGU6IGZ1bmN0aW9uIF9jcmVhdGVOb2RlKGRhdGEsIHBhcmVudE5vZGUsIGRlcHRoLCBpbmRleCwgZXhwYW5kZWQpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBkYXRhOiBkYXRhLAogICAgICAgIGRlcHRoOiBkZXB0aCwKICAgICAgICBpbmRleDogaW5kZXgsCiAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlLAogICAgICAgIGxlYWY6IHRoaXMuaGFzQ2hpbGRyZW4oZGF0YSkgPT09IGZhbHNlLAogICAgICAgIGV4cGFuZGVkOiBleHBhbmRlZAogICAgICB9OwogICAgfSwKCiAgICAvKioNCiAgICAgKiBJdGVyYXRlIGNoaWxkbm9kZXMgYW5kIHB1dCB0aGVtIHRvIHRoZSBnaXZlbiBjb2xsZWN0aW9uLg0KICAgICAqDQogICAgICogQHBhcmFtIHtJVHJlZU5vZGV9IHBhcmVudE5vZGUgICBQYXJlbnQgbm9kZSB3aG9zIGNoaWxkIHdpbGwgYmUgaXRlcmF0ZWQNCiAgICAgKiBAcGFyYW0ge0lUcmVlTm9kZVtdfSBjb2xsZWN0aW9uIEFuIGFycmF5IGNvbGxlY3Rpb24gdG8gc3RvcmUgdGhlIGNoaWxkbm9kZXMNCiAgICAgKiBAcmV0dXJucyB7dm9pZH0NCiAgICAgKiBAcHJpdmF0ZQ0KICAgICAqLwogICAgX2l0ZXJhdGVDaGlsZE5vZGU6IGZ1bmN0aW9uIF9pdGVyYXRlQ2hpbGROb2RlKHBhcmVudE5vZGUsIGNvbGxlY3Rpb24pIHsKICAgICAgZm9yICh2YXIgaSA9IHBhcmVudE5vZGUuaW5kZXg7IGkgPCB0aGlzLnRyZWVOb2Rlcy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBub2RlID0gdGhpcy50cmVlTm9kZXNbaV07CgogICAgICAgIGlmIChub2RlLnBhcmVudCA9PT0gcGFyZW50Tm9kZSkgewogICAgICAgICAgY29sbGVjdGlvbi5wdXNoKG5vZGUpOwoKICAgICAgICAgIGlmICh0aGlzLmhhc0NoaWxkcmVuKG5vZGUuZGF0YSkpIHsKICAgICAgICAgICAgdGhpcy5faXRlcmF0ZUNoaWxkTm9kZShub2RlLCBjb2xsZWN0aW9uKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0sCgogICAgLyoqDQogICAgICogQ29sbGFwc2UgdGhlIGdpdmVuIG5vZGUgYW5kIGZpcmVzIGV2ZW50IDxiPmNvbGxhcHNlZDwvYj4uDQogICAgICoNCiAgICAgKiBAcGFyYW0ge0lUcmVlTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBjb2xsYXBzZQ0KICAgICAqIEByZXR1cm5zIHt2b2lkfQ0KICAgICAqLwogICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlKG5vZGUpIHsKICAgICAgdmFyIGNvbGxhcHNlZE5vZGVzID0gW107CiAgICAgIGNvbGxhcHNlZE5vZGVzLnB1c2gobm9kZSk7CgogICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbihub2RlLmRhdGEpKSB7CiAgICAgICAgdGhpcy5faXRlcmF0ZUNoaWxkTm9kZShub2RlLCBjb2xsYXBzZWROb2Rlcyk7CiAgICAgIH0KCiAgICAgIGZvciAodmFyIF9pID0gMCwgX2NvbGxhcHNlZE5vZGVzID0gY29sbGFwc2VkTm9kZXM7IF9pIDwgX2NvbGxhcHNlZE5vZGVzLmxlbmd0aDsgX2krKykgewogICAgICAgIHZhciBpdGVtID0gX2NvbGxhcHNlZE5vZGVzW19pXTsKICAgICAgICBpdGVtLmV4cGFuZGVkID0gZmFsc2U7CiAgICAgIH0KCiAgICAgIHRoaXMuVHJlZUdyaWQuZmlyZUV2ZW50KCdjb2xsYXBzZWQnLCBub2RlKTsKICAgIH0sCgogICAgLyoqDQogICAgICogRXhwYW5kIHRoZSBnaXZlbiBub2RlIGFuZCBmaXJlcyBldmVudCA8Yj5leHBhbmRlZDwvYj4uDQogICAgICoNCiAgICAgKiBAcGFyYW0ge0lUcmVlTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBleHBhbmQNCiAgICAgKiBAcmV0dXJucyB7dm9pZH0NCiAgICAgKi8KICAgIGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKG5vZGUpIHsKICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4obm9kZS5kYXRhKTsKICAgICAgdmFyIGFkYXB0ZXIgPSB0aGlzLlRyZWVHcmlkLmRhdGFTb3VyY2U7CgogICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbihub2RlLmRhdGEpICYmIEhlbHBlci5pc0VtcHR5KGNoaWxkcmVuKSAmJiBhZGFwdGVyIGluc3RhbmNlb2YgQnNUcmVlU3RvcmUpIHsKICAgICAgICBhZGFwdGVyLmxvYWRDaGlsZHJlbihub2RlLmRhdGEpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7CiAgICAgICAgICB2YXIgcmVzcG9uc2VEYXRhID0gcmVzcG9uc2UuZGF0YTsgLy8gRGlydHkgY2hlY2ssIHBvcHVsYXRlIG5vZGVzIGlmIGNvbmRpdGlvbiBoYXMgYmVlbiBtZXQKCiAgICAgICAgICBpZiAocmVzcG9uc2VEYXRhLmhhc093blByb3BlcnR5KGFkYXB0ZXIuX2NvbmZpZy5kYXRhUHJvcGVydHkpICYmIHJlc3BvbnNlRGF0YS5kYXRhLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgX3RoaXMuX2FwcGVuZENoaWxkKG5vZGUsIF90aGlzLmdldENoaWxkcmVuKG5vZGUuZGF0YSkpOwogICAgICAgICAgfQogICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgewogICAgICAgICAgX3RoaXMuVHJlZUdyaWQuZmlyZUV2ZW50KCdlcnJvcicsIGVycm9yKTsKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmIChIZWxwZXIuaXNFbXB0eShjaGlsZHJlbikpIHsKICAgICAgICBub2RlLmxlYWYgPSB0cnVlOwogICAgICB9CgogICAgICBpZiAobm9kZS5sZWFmID09PSBmYWxzZSkgewogICAgICAgIG5vZGUuZXhwYW5kZWQgPSB0cnVlOwogICAgICAgIHRoaXMuVHJlZUdyaWQuZmlyZUV2ZW50KCdleHBhbmRlZCcsIG5vZGUpOwogICAgICB9CiAgICB9LAoKICAgIC8qKg0KICAgICAqIEdldCBjaGlsZHJlbiBvZiB0aGUgZ2l2ZW4gZGF0YSBtb2RlbC4NCiAgICAgKg0KICAgICAqIEBwYXJhbSB7QnNNb2RlbHxPYmplY3R9IGl0ZW0gRGF0YSBtb2RlbA0KICAgICAqIEByZXR1cm5zIHtCc01vZGVsW118T2JqZWN0W119IFRoZSBjaGlsZCBpdGVtcw0KICAgICAqLwogICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uIGdldENoaWxkcmVuKGl0ZW0pIHsKICAgICAgcmV0dXJuIGl0ZW1bdGhpcy5jaGlsZHJlbkZpZWxkbWFwXTsKICAgIH0sCgogICAgLyoqDQogICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRhdGEgbW9kZWwgaGFzIG9uZSBvciBtb3JlIGNoaWxkIG9yIG5vdC4NCiAgICAgKg0KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIERhdGEgbW9kZWwgdG8gY2hlY2sNCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVFJVRSBpZiB0aGUgZ2l2ZW4gbW9kZWwgaGFzIGNoaWxkIG90aGVyd2lzZSBGQUxTRQ0KICAgICAqLwogICAgaGFzQ2hpbGRyZW46IGZ1bmN0aW9uIGhhc0NoaWxkcmVuKGl0ZW0pIHsKICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbihpdGVtKTsKICAgICAgcmV0dXJuIGl0ZW0uaGFzQ2hpbGRyZW4gPT09IHRydWUgfHwgaXRlbS5sZWFmID09PSBmYWxzZSB8fCBIZWxwZXIuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMDsKICAgIH0sCgogICAgLyoqDQogICAgICogUG9wdWxhdGUgYW5kIGNyZWF0ZSBsaXN0IG9mIG5vZGVzIGZyb20gdGhlIGdpdmVuIGRhdGEgc291cmNlcy4NCiAgICAgKg0KICAgICAqIEBwYXJhbSB7aW50fSBkZXB0aCAgICAgICAgICAgICAgICAgICBOb2RlIGRlcHRoIGxldmVsDQogICAgICogQHBhcmFtIHtCc01vZGVsW118T2JqZWN0W119IHNvdXJjZXMgIENvbGxlY3Rpb24gb2YgZGF0YSBtb2RlbA0KICAgICAqIEBwYXJhbSB7SVRyZWVOb2RlfCp9IHBhcmVudE5vZGUgICAgICBQYXJlbnQgbm9kZQ0KICAgICAqIEByZXR1cm5zIHt2b2lkfQ0KICAgICAqLwogICAgcG9wdWxhdGVOb2RlczogZnVuY3Rpb24gcG9wdWxhdGVOb2RlcyhkZXB0aCwgc291cmNlcykgewogICAgICB2YXIgcGFyZW50Tm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDsKICAgICAgdmFyIGV4cGFuZERlcHRoID0gdGhpcy5UcmVlR3JpZC5leHBhbmREZXB0aDsKICAgICAgdmFyIGV4cGFuZGVkID0gdGhpcy5UcmVlR3JpZC5leHBhbmRlZDsKICAgICAgdmFyIHJvd0luZGV4ID0gdGhpcy50cmVlTm9kZXMubGVuZ3RoOwoKICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzb3VyY2VzKSwKICAgICAgICAgIF9zdGVwMjsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBzb3VyY2UgPSBfc3RlcDIudmFsdWU7CgogICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jcmVhdGVOb2RlKHNvdXJjZSwgcGFyZW50Tm9kZSwgZGVwdGgsIHJvd0luZGV4LCBzb3VyY2UuZXhwYW5kZWQgPT09IHRydWUgPyB0cnVlIDogZXhwYW5kRGVwdGggPiBkZXB0aCA/IHRydWUgOiBleHBhbmRlZCk7CgogICAgICAgICAgcm93SW5kZXggPSB0aGlzLnRyZWVOb2Rlcy5wdXNoKG5vZGUpOwoKICAgICAgICAgIGlmICh0aGlzLmhhc0NoaWxkcmVuKHNvdXJjZSkpIHsKICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZU5vZGVzKGRlcHRoICsgMSwgdGhpcy5nZXRDaGlsZHJlbihzb3VyY2UpLCBub2RlKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjIuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjIuZigpOwogICAgICB9CiAgICB9CiAgfQp9Ow=="},{"version":3,"sources":["BsTreegridItems.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\r\n  <tbody>\r\n    <tr\r\n      v-for=\"(item, index) in visibleItems\"\r\n      :key=\"'row-' + index\"\r\n      :class=\"_rowClasses(index)\"\r\n      role=\"row\">\r\n      <slot v-bind=\"{ index: index, item: item.data, level: item.depth, node: item }\">\r\n        <template v-for=\"(column, colIdx) in columns\">\r\n          <component\r\n            :is=\"_componentName(colIdx)\"\r\n            :column=\"column\"\r\n            :index=\"colIdx\"\r\n            :item=\"item.data\"\r\n            :node=\"item\"\r\n            :key=\"column.field + '-' + _uuid()\" />\r\n        </template>\r\n      </slot>\r\n    </tr>\r\n  </tbody>\r\n</template>\r\n\r\n<script>\r\n/**\r\n * TreeNode data type.\r\n *\r\n * @typedef {Object} ITreeNode\r\n * @property {BsModel|Object} data The Node's data model\r\n * @property {number} depth        The Node's depth level in the TreeList\r\n * @property {number} index        The Node's absolute index position in the ArrayList\r\n * @property {ITreeNode} parent    The parent of this Node\r\n * @property {boolean} leaf        The Node's flag, describe it is the last child in the TreeList or not\r\n * @property {boolean} expanded    The Node's state, expanded or collapsed\r\n */\r\nimport BsTreeStore from \"../../model/BsTreeStore\";\r\nimport BsTreegridCell from \"./BsTreegridCell\";\r\nimport BsGridCell from \"./BsGridCell\";\r\nimport Common from \"../../mixins/Common\";\r\nimport Helper from \"../../utils/Helper\";\r\n\r\nexport default {\r\n    name: \"BsTreegridItems\",\r\n    components: {BsTreegridCell, BsGridCell},\r\n    mixins: [Common],\r\n    inject: ['TreeGrid'],\r\n    props: {\r\n        columns: {\r\n            type: Array,\r\n            default: undefined\r\n        },\r\n        items: {\r\n            type: Array,\r\n            default: undefined\r\n        }\r\n    },\r\n    data: () => ({\r\n        childrenFieldmap: '',\r\n        treeNodes: []\r\n    }),\r\n    computed: {\r\n        visibleItems() {\r\n            return this.treeNodes.filter(node => {\r\n                return node.depth === 0 || node.expanded || node.parent.expanded;\r\n            });\r\n        }\r\n    },\r\n    created() {\r\n        this.treeNodes = [];\r\n        this.childrenFieldmap = this.TreeGrid.childrenFieldmap;\r\n    },\r\n    beforeDestroy() {\r\n        this.treeNodes = null;\r\n    },\r\n    methods: {\r\n        /**\r\n         * Get component's name at the given index.\r\n         *\r\n         * @param {int} columnIndex Column index position\r\n         * @returns {string} The component's name\r\n         * @private\r\n         */\r\n        _componentName(columnIndex) {\r\n            return columnIndex === 0 ? 'bs-treegrid-cell' : 'bs-grid-cell';\r\n        },\r\n        /**\r\n         * Get row css class at the given index.\r\n         *\r\n         * @param {int} index Absolute index position\r\n         * @returns {string[]} Css classes\r\n         * @private\r\n         */\r\n        _rowClasses(index) {\r\n            return [\r\n                index % 2 === 0 ? 'md-grid-row' : 'md-grid-row-alt',\r\n            ]\r\n        },\r\n        /**\r\n         * Append childnodes to the treeitems.\r\n         *\r\n         * @param {ITreeNode} parentNode     Parent node\r\n         * @param {BsModel[]|Object[]} datas Collection of data model\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        _appendChild(parentNode, datas) {\r\n            let tmpNodes = [];\r\n\r\n            for (let i = 0; i < this.treeNodes.length; i++) {\r\n                const node = this.treeNodes[i];\r\n                tmpNodes.push(node);\r\n\r\n                if (node === parentNode) {\r\n                    let rowIndex = i + 1;\r\n                    for (const data of datas) {\r\n                        const childNode = this._createNode(data, parentNode, (parentNode.depth + 1), rowIndex, false);\r\n                        tmpNodes.push(childNode);\r\n                        rowIndex++;\r\n                    }\r\n                }\r\n                node.index = i;\r\n            }\r\n\r\n            this.treeNodes = tmpNodes;\r\n        },\r\n        /**\r\n         * Create ITreeNode from the given data model.\r\n         *\r\n         * @param {BsModel|Object} data   Data model\r\n         * @param {ITreeNode} parentNode  Parent node\r\n         * @param {int} depth             Node depth level within the TreeList\r\n         * @param {int} index             Absolute node index position within the TreeList\r\n         * @param {boolean} expanded      The node state\r\n         * @returns {ITreeNode} The treeNode\r\n         * @private\r\n         */\r\n        _createNode(data, parentNode, depth, index, expanded) {\r\n            return {\r\n                data: data,\r\n                depth: depth,\r\n                index: index,\r\n                parent: parentNode,\r\n                leaf: this.hasChildren(data) === false,\r\n                expanded: expanded\r\n            }\r\n        },\r\n        /**\r\n         * Iterate childnodes and put them to the given collection.\r\n         *\r\n         * @param {ITreeNode} parentNode   Parent node whos child will be iterated\r\n         * @param {ITreeNode[]} collection An array collection to store the childnodes\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        _iterateChildNode(parentNode, collection) {\r\n            for (let i = parentNode.index; i < this.treeNodes.length; i++) {\r\n                const node = this.treeNodes[i];\r\n                if (node.parent === parentNode) {\r\n                    collection.push(node);\r\n                    if (this.hasChildren(node.data)) {\r\n                        this._iterateChildNode(node, collection);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * Collapse the given node and fires event <b>collapsed</b>.\r\n         *\r\n         * @param {ITreeNode} node The node to collapse\r\n         * @returns {void}\r\n         */\r\n        collapse(node) {\r\n            let collapsedNodes = [];\r\n\r\n            collapsedNodes.push(node);\r\n            if (this.hasChildren(node.data)) {\r\n                this._iterateChildNode(node, collapsedNodes);\r\n            }\r\n            for (const item of collapsedNodes) {\r\n                item.expanded = false;\r\n            }\r\n\r\n            this.TreeGrid.fireEvent('collapsed', node);\r\n        },\r\n        /**\r\n         * Expand the given node and fires event <b>expanded</b>.\r\n         *\r\n         * @param {ITreeNode} node The node to expand\r\n         * @returns {void}\r\n         */\r\n        expand(node) {\r\n            const children = this.getChildren(node.data);\r\n            const adapter = this.TreeGrid.dataSource;\r\n\r\n            if (this.hasChildren(node.data) && Helper.isEmpty(children) && (adapter instanceof BsTreeStore)) {\r\n                adapter.loadChildren(node.data).then(response => {\r\n                    const responseData = response.data;\r\n\r\n                    // Dirty check, populate nodes if condition has been met\r\n                    if (responseData.hasOwnProperty(adapter._config.dataProperty) && responseData.data.length > 0) {\r\n                        this._appendChild(node, this.getChildren(node.data));\r\n                    }\r\n                }).catch(error => {\r\n                    this.TreeGrid.fireEvent('error', error);\r\n                });\r\n            } else if (Helper.isEmpty(children)) {\r\n                node.leaf = true;\r\n            }\r\n\r\n            if (node.leaf === false) {\r\n                node.expanded = true;\r\n                this.TreeGrid.fireEvent('expanded', node);\r\n            }\r\n        },\r\n        /**\r\n         * Get children of the given data model.\r\n         *\r\n         * @param {BsModel|Object} item Data model\r\n         * @returns {BsModel[]|Object[]} The child items\r\n         */\r\n        getChildren(item) {\r\n            return item[this.childrenFieldmap];\r\n        },\r\n        /**\r\n         * Check if the given data model has one or more child or not.\r\n         *\r\n         * @param {Object} item Data model to check\r\n         * @returns {boolean} TRUE if the given model has child otherwise FALSE\r\n         */\r\n        hasChildren(item) {\r\n            const children = this.getChildren(item);\r\n\r\n            return item.hasChildren === true || item.leaf === false || (Helper.isArray(children) && children.length > 0);\r\n        },\r\n        /**\r\n         * Populate and create list of nodes from the given data sources.\r\n         *\r\n         * @param {int} depth                   Node depth level\r\n         * @param {BsModel[]|Object[]} sources  Collection of data model\r\n         * @param {ITreeNode|*} parentNode      Parent node\r\n         * @returns {void}\r\n         */\r\n        populateNodes(depth, sources, parentNode = null) {\r\n            const expandDepth = this.TreeGrid.expandDepth;\r\n            const expanded = this.TreeGrid.expanded;\r\n            let rowIndex = this.treeNodes.length;\r\n\r\n            for (const source of sources) {\r\n                const node = this._createNode(\r\n                    source, parentNode, depth, rowIndex,\r\n                    (source.expanded === true ? true : (expandDepth > depth ? true : expanded))\r\n                );\r\n\r\n                rowIndex = this.treeNodes.push(node);\r\n                if (this.hasChildren(source)) {\r\n                    this.populateNodes(depth + 1, this.getChildren(source), node);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n\r\n</style>\r\n"],"sourceRoot":"node_modules/vue-mdbootstrap/src/components/BsGrid"}]}
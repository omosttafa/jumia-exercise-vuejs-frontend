{"remainingRequest":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\vue-mdbootstrap\\src\\components\\BsGrid\\BsTreegridItems.vue?vue&type=script&lang=js&","dependencies":[{"path":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\vue-mdbootstrap\\src\\components\\BsGrid\\BsTreegridItems.vue","mtime":1609323834000},{"path":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"O:\\WORK\\JUMIA\\vuejs\\new\\jumia-vue\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KDQovKioNCiAqIFRyZWVOb2RlIGRhdGEgdHlwZS4NCiAqDQogKiBAdHlwZWRlZiB7T2JqZWN0fSBJVHJlZU5vZGUNCiAqIEBwcm9wZXJ0eSB7QnNNb2RlbHxPYmplY3R9IGRhdGEgVGhlIE5vZGUncyBkYXRhIG1vZGVsDQogKiBAcHJvcGVydHkge251bWJlcn0gZGVwdGggICAgICAgIFRoZSBOb2RlJ3MgZGVwdGggbGV2ZWwgaW4gdGhlIFRyZWVMaXN0DQogKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggICAgICAgIFRoZSBOb2RlJ3MgYWJzb2x1dGUgaW5kZXggcG9zaXRpb24gaW4gdGhlIEFycmF5TGlzdA0KICogQHByb3BlcnR5IHtJVHJlZU5vZGV9IHBhcmVudCAgICBUaGUgcGFyZW50IG9mIHRoaXMgTm9kZQ0KICogQHByb3BlcnR5IHtib29sZWFufSBsZWFmICAgICAgICBUaGUgTm9kZSdzIGZsYWcsIGRlc2NyaWJlIGl0IGlzIHRoZSBsYXN0IGNoaWxkIGluIHRoZSBUcmVlTGlzdCBvciBub3QNCiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXhwYW5kZWQgICAgVGhlIE5vZGUncyBzdGF0ZSwgZXhwYW5kZWQgb3IgY29sbGFwc2VkDQogKi8NCmltcG9ydCBCc1RyZWVTdG9yZSBmcm9tICIuLi8uLi9tb2RlbC9Cc1RyZWVTdG9yZSI7DQppbXBvcnQgQnNUcmVlZ3JpZENlbGwgZnJvbSAiLi9Cc1RyZWVncmlkQ2VsbCI7DQppbXBvcnQgQnNHcmlkQ2VsbCBmcm9tICIuL0JzR3JpZENlbGwiOw0KaW1wb3J0IENvbW1vbiBmcm9tICIuLi8uLi9taXhpbnMvQ29tbW9uIjsNCmltcG9ydCBIZWxwZXIgZnJvbSAiLi4vLi4vdXRpbHMvSGVscGVyIjsNCg0KZXhwb3J0IGRlZmF1bHQgew0KICAgIG5hbWU6ICJCc1RyZWVncmlkSXRlbXMiLA0KICAgIGNvbXBvbmVudHM6IHtCc1RyZWVncmlkQ2VsbCwgQnNHcmlkQ2VsbH0sDQogICAgbWl4aW5zOiBbQ29tbW9uXSwNCiAgICBpbmplY3Q6IFsnVHJlZUdyaWQnXSwNCiAgICBwcm9wczogew0KICAgICAgICBjb2x1bW5zOiB7DQogICAgICAgICAgICB0eXBlOiBBcnJheSwNCiAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZA0KICAgICAgICB9LA0KICAgICAgICBpdGVtczogew0KICAgICAgICAgICAgdHlwZTogQXJyYXksDQogICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQNCiAgICAgICAgfQ0KICAgIH0sDQogICAgZGF0YTogKCkgPT4gKHsNCiAgICAgICAgY2hpbGRyZW5GaWVsZG1hcDogJycsDQogICAgICAgIHRyZWVOb2RlczogW10NCiAgICB9KSwNCiAgICBjb21wdXRlZDogew0KICAgICAgICB2aXNpYmxlSXRlbXMoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlTm9kZXMuZmlsdGVyKG5vZGUgPT4gew0KICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmRlcHRoID09PSAwIHx8IG5vZGUuZXhwYW5kZWQgfHwgbm9kZS5wYXJlbnQuZXhwYW5kZWQ7DQogICAgICAgICAgICB9KTsNCiAgICAgICAgfQ0KICAgIH0sDQogICAgY3JlYXRlZCgpIHsNCiAgICAgICAgdGhpcy50cmVlTm9kZXMgPSBbXTsNCiAgICAgICAgdGhpcy5jaGlsZHJlbkZpZWxkbWFwID0gdGhpcy5UcmVlR3JpZC5jaGlsZHJlbkZpZWxkbWFwOw0KICAgIH0sDQogICAgYmVmb3JlRGVzdHJveSgpIHsNCiAgICAgICAgdGhpcy50cmVlTm9kZXMgPSBudWxsOw0KICAgIH0sDQogICAgbWV0aG9kczogew0KICAgICAgICAvKioNCiAgICAgICAgICogR2V0IGNvbXBvbmVudCdzIG5hbWUgYXQgdGhlIGdpdmVuIGluZGV4Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ge2ludH0gY29sdW1uSW5kZXggQ29sdW1uIGluZGV4IHBvc2l0aW9uDQogICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21wb25lbnQncyBuYW1lDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqLw0KICAgICAgICBfY29tcG9uZW50TmFtZShjb2x1bW5JbmRleCkgew0KICAgICAgICAgICAgcmV0dXJuIGNvbHVtbkluZGV4ID09PSAwID8gJ2JzLXRyZWVncmlkLWNlbGwnIDogJ2JzLWdyaWQtY2VsbCc7DQogICAgICAgIH0sDQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXQgcm93IGNzcyBjbGFzcyBhdCB0aGUgZ2l2ZW4gaW5kZXguDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB7aW50fSBpbmRleCBBYnNvbHV0ZSBpbmRleCBwb3NpdGlvbg0KICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IENzcyBjbGFzc2VzDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqLw0KICAgICAgICBfcm93Q2xhc3NlcyhpbmRleCkgew0KICAgICAgICAgICAgcmV0dXJuIFsNCiAgICAgICAgICAgICAgICBpbmRleCAlIDIgPT09IDAgPyAnbWQtZ3JpZC1yb3cnIDogJ21kLWdyaWQtcm93LWFsdCcsDQogICAgICAgICAgICBdDQogICAgICAgIH0sDQogICAgICAgIC8qKg0KICAgICAgICAgKiBBcHBlbmQgY2hpbGRub2RlcyB0byB0aGUgdHJlZWl0ZW1zLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ge0lUcmVlTm9kZX0gcGFyZW50Tm9kZSAgICAgUGFyZW50IG5vZGUNCiAgICAgICAgICogQHBhcmFtIHtCc01vZGVsW118T2JqZWN0W119IGRhdGFzIENvbGxlY3Rpb24gb2YgZGF0YSBtb2RlbA0KICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH0NCiAgICAgICAgICogQHByaXZhdGUNCiAgICAgICAgICovDQogICAgICAgIF9hcHBlbmRDaGlsZChwYXJlbnROb2RlLCBkYXRhcykgew0KICAgICAgICAgICAgbGV0IHRtcE5vZGVzID0gW107DQoNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmVlTm9kZXMubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy50cmVlTm9kZXNbaV07DQogICAgICAgICAgICAgICAgdG1wTm9kZXMucHVzaChub2RlKTsNCg0KICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBwYXJlbnROb2RlKSB7DQogICAgICAgICAgICAgICAgICAgIGxldCByb3dJbmRleCA9IGkgKyAxOw0KICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgZGF0YXMpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMuX2NyZWF0ZU5vZGUoZGF0YSwgcGFyZW50Tm9kZSwgKHBhcmVudE5vZGUuZGVwdGggKyAxKSwgcm93SW5kZXgsIGZhbHNlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRtcE5vZGVzLnB1c2goY2hpbGROb2RlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4Kys7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgbm9kZS5pbmRleCA9IGk7DQogICAgICAgICAgICB9DQoNCiAgICAgICAgICAgIHRoaXMudHJlZU5vZGVzID0gdG1wTm9kZXM7DQogICAgICAgIH0sDQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgSVRyZWVOb2RlIGZyb20gdGhlIGdpdmVuIGRhdGEgbW9kZWwuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB7QnNNb2RlbHxPYmplY3R9IGRhdGEgICBEYXRhIG1vZGVsDQogICAgICAgICAqIEBwYXJhbSB7SVRyZWVOb2RlfSBwYXJlbnROb2RlICBQYXJlbnQgbm9kZQ0KICAgICAgICAgKiBAcGFyYW0ge2ludH0gZGVwdGggICAgICAgICAgICAgTm9kZSBkZXB0aCBsZXZlbCB3aXRoaW4gdGhlIFRyZWVMaXN0DQogICAgICAgICAqIEBwYXJhbSB7aW50fSBpbmRleCAgICAgICAgICAgICBBYnNvbHV0ZSBub2RlIGluZGV4IHBvc2l0aW9uIHdpdGhpbiB0aGUgVHJlZUxpc3QNCiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBleHBhbmRlZCAgICAgIFRoZSBub2RlIHN0YXRlDQogICAgICAgICAqIEByZXR1cm5zIHtJVHJlZU5vZGV9IFRoZSB0cmVlTm9kZQ0KICAgICAgICAgKiBAcHJpdmF0ZQ0KICAgICAgICAgKi8NCiAgICAgICAgX2NyZWF0ZU5vZGUoZGF0YSwgcGFyZW50Tm9kZSwgZGVwdGgsIGluZGV4LCBleHBhbmRlZCkgew0KICAgICAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLA0KICAgICAgICAgICAgICAgIGRlcHRoOiBkZXB0aCwNCiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsDQogICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlLA0KICAgICAgICAgICAgICAgIGxlYWY6IHRoaXMuaGFzQ2hpbGRyZW4oZGF0YSkgPT09IGZhbHNlLA0KICAgICAgICAgICAgICAgIGV4cGFuZGVkOiBleHBhbmRlZA0KICAgICAgICAgICAgfQ0KICAgICAgICB9LA0KICAgICAgICAvKioNCiAgICAgICAgICogSXRlcmF0ZSBjaGlsZG5vZGVzIGFuZCBwdXQgdGhlbSB0byB0aGUgZ2l2ZW4gY29sbGVjdGlvbi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHtJVHJlZU5vZGV9IHBhcmVudE5vZGUgICBQYXJlbnQgbm9kZSB3aG9zIGNoaWxkIHdpbGwgYmUgaXRlcmF0ZWQNCiAgICAgICAgICogQHBhcmFtIHtJVHJlZU5vZGVbXX0gY29sbGVjdGlvbiBBbiBhcnJheSBjb2xsZWN0aW9uIHRvIHN0b3JlIHRoZSBjaGlsZG5vZGVzDQogICAgICAgICAqIEByZXR1cm5zIHt2b2lkfQ0KICAgICAgICAgKiBAcHJpdmF0ZQ0KICAgICAgICAgKi8NCiAgICAgICAgX2l0ZXJhdGVDaGlsZE5vZGUocGFyZW50Tm9kZSwgY29sbGVjdGlvbikgew0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcmVudE5vZGUuaW5kZXg7IGkgPCB0aGlzLnRyZWVOb2Rlcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnRyZWVOb2Rlc1tpXTsNCiAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgPT09IHBhcmVudE5vZGUpIHsNCiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKG5vZGUpOw0KICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbihub2RlLmRhdGEpKSB7DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVyYXRlQ2hpbGROb2RlKG5vZGUsIGNvbGxlY3Rpb24pOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICB9LA0KICAgICAgICAvKioNCiAgICAgICAgICogQ29sbGFwc2UgdGhlIGdpdmVuIG5vZGUgYW5kIGZpcmVzIGV2ZW50IDxiPmNvbGxhcHNlZDwvYj4uDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB7SVRyZWVOb2RlfSBub2RlIFRoZSBub2RlIHRvIGNvbGxhcHNlDQogICAgICAgICAqIEByZXR1cm5zIHt2b2lkfQ0KICAgICAgICAgKi8NCiAgICAgICAgY29sbGFwc2Uobm9kZSkgew0KICAgICAgICAgICAgbGV0IGNvbGxhcHNlZE5vZGVzID0gW107DQoNCiAgICAgICAgICAgIGNvbGxhcHNlZE5vZGVzLnB1c2gobm9kZSk7DQogICAgICAgICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbihub2RlLmRhdGEpKSB7DQogICAgICAgICAgICAgICAgdGhpcy5faXRlcmF0ZUNoaWxkTm9kZShub2RlLCBjb2xsYXBzZWROb2Rlcyk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGFwc2VkTm9kZXMpIHsNCiAgICAgICAgICAgICAgICBpdGVtLmV4cGFuZGVkID0gZmFsc2U7DQogICAgICAgICAgICB9DQoNCiAgICAgICAgICAgIHRoaXMuVHJlZUdyaWQuZmlyZUV2ZW50KCdjb2xsYXBzZWQnLCBub2RlKTsNCiAgICAgICAgfSwNCiAgICAgICAgLyoqDQogICAgICAgICAqIEV4cGFuZCB0aGUgZ2l2ZW4gbm9kZSBhbmQgZmlyZXMgZXZlbnQgPGI+ZXhwYW5kZWQ8L2I+Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ge0lUcmVlTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBleHBhbmQNCiAgICAgICAgICogQHJldHVybnMge3ZvaWR9DQogICAgICAgICAqLw0KICAgICAgICBleHBhbmQobm9kZSkgew0KICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKG5vZGUuZGF0YSk7DQogICAgICAgICAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5UcmVlR3JpZC5kYXRhU291cmNlOw0KDQogICAgICAgICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbihub2RlLmRhdGEpICYmIEhlbHBlci5pc0VtcHR5KGNoaWxkcmVuKSAmJiAoYWRhcHRlciBpbnN0YW5jZW9mIEJzVHJlZVN0b3JlKSkgew0KICAgICAgICAgICAgICAgIGFkYXB0ZXIubG9hZENoaWxkcmVuKG5vZGUuZGF0YSkudGhlbihyZXNwb25zZSA9PiB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlLmRhdGE7DQoNCiAgICAgICAgICAgICAgICAgICAgLy8gRGlydHkgY2hlY2ssIHBvcHVsYXRlIG5vZGVzIGlmIGNvbmRpdGlvbiBoYXMgYmVlbiBtZXQNCiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlRGF0YS5oYXNPd25Qcm9wZXJ0eShhZGFwdGVyLl9jb25maWcuZGF0YVByb3BlcnR5KSAmJiByZXNwb25zZURhdGEuZGF0YS5sZW5ndGggPiAwKSB7DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmRDaGlsZChub2RlLCB0aGlzLmdldENoaWxkcmVuKG5vZGUuZGF0YSkpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gew0KICAgICAgICAgICAgICAgICAgICB0aGlzLlRyZWVHcmlkLmZpcmVFdmVudCgnZXJyb3InLCBlcnJvcik7DQogICAgICAgICAgICAgICAgfSk7DQogICAgICAgICAgICB9IGVsc2UgaWYgKEhlbHBlci5pc0VtcHR5KGNoaWxkcmVuKSkgew0KICAgICAgICAgICAgICAgIG5vZGUubGVhZiA9IHRydWU7DQogICAgICAgICAgICB9DQoNCiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgPT09IGZhbHNlKSB7DQogICAgICAgICAgICAgICAgbm9kZS5leHBhbmRlZCA9IHRydWU7DQogICAgICAgICAgICAgICAgdGhpcy5UcmVlR3JpZC5maXJlRXZlbnQoJ2V4cGFuZGVkJywgbm9kZSk7DQogICAgICAgICAgICB9DQogICAgICAgIH0sDQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXQgY2hpbGRyZW4gb2YgdGhlIGdpdmVuIGRhdGEgbW9kZWwuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB7QnNNb2RlbHxPYmplY3R9IGl0ZW0gRGF0YSBtb2RlbA0KICAgICAgICAgKiBAcmV0dXJucyB7QnNNb2RlbFtdfE9iamVjdFtdfSBUaGUgY2hpbGQgaXRlbXMNCiAgICAgICAgICovDQogICAgICAgIGdldENoaWxkcmVuKGl0ZW0pIHsNCiAgICAgICAgICAgIHJldHVybiBpdGVtW3RoaXMuY2hpbGRyZW5GaWVsZG1hcF07DQogICAgICAgIH0sDQogICAgICAgIC8qKg0KICAgICAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZGF0YSBtb2RlbCBoYXMgb25lIG9yIG1vcmUgY2hpbGQgb3Igbm90Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBEYXRhIG1vZGVsIHRvIGNoZWNrDQogICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIGlmIHRoZSBnaXZlbiBtb2RlbCBoYXMgY2hpbGQgb3RoZXJ3aXNlIEZBTFNFDQogICAgICAgICAqLw0KICAgICAgICBoYXNDaGlsZHJlbihpdGVtKSB7DQogICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oaXRlbSk7DQoNCiAgICAgICAgICAgIHJldHVybiBpdGVtLmhhc0NoaWxkcmVuID09PSB0cnVlIHx8IGl0ZW0ubGVhZiA9PT0gZmFsc2UgfHwgKEhlbHBlci5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAwKTsNCiAgICAgICAgfSwNCiAgICAgICAgLyoqDQogICAgICAgICAqIFBvcHVsYXRlIGFuZCBjcmVhdGUgbGlzdCBvZiBub2RlcyBmcm9tIHRoZSBnaXZlbiBkYXRhIHNvdXJjZXMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB7aW50fSBkZXB0aCAgICAgICAgICAgICAgICAgICBOb2RlIGRlcHRoIGxldmVsDQogICAgICAgICAqIEBwYXJhbSB7QnNNb2RlbFtdfE9iamVjdFtdfSBzb3VyY2VzICBDb2xsZWN0aW9uIG9mIGRhdGEgbW9kZWwNCiAgICAgICAgICogQHBhcmFtIHtJVHJlZU5vZGV8Kn0gcGFyZW50Tm9kZSAgICAgIFBhcmVudCBub2RlDQogICAgICAgICAqIEByZXR1cm5zIHt2b2lkfQ0KICAgICAgICAgKi8NCiAgICAgICAgcG9wdWxhdGVOb2RlcyhkZXB0aCwgc291cmNlcywgcGFyZW50Tm9kZSA9IG51bGwpIHsNCiAgICAgICAgICAgIGNvbnN0IGV4cGFuZERlcHRoID0gdGhpcy5UcmVlR3JpZC5leHBhbmREZXB0aDsNCiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gdGhpcy5UcmVlR3JpZC5leHBhbmRlZDsNCiAgICAgICAgICAgIGxldCByb3dJbmRleCA9IHRoaXMudHJlZU5vZGVzLmxlbmd0aDsNCg0KICAgICAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykgew0KICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9jcmVhdGVOb2RlKA0KICAgICAgICAgICAgICAgICAgICBzb3VyY2UsIHBhcmVudE5vZGUsIGRlcHRoLCByb3dJbmRleCwNCiAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5leHBhbmRlZCA9PT0gdHJ1ZSA/IHRydWUgOiAoZXhwYW5kRGVwdGggPiBkZXB0aCA/IHRydWUgOiBleHBhbmRlZCkpDQogICAgICAgICAgICAgICAgKTsNCg0KICAgICAgICAgICAgICAgIHJvd0luZGV4ID0gdGhpcy50cmVlTm9kZXMucHVzaChub2RlKTsNCiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbihzb3VyY2UpKSB7DQogICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdWxhdGVOb2RlcyhkZXB0aCArIDEsIHRoaXMuZ2V0Q2hpbGRyZW4oc291cmNlKSwgbm9kZSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgfQ0KfQ0K"},{"version":3,"sources":["BsTreegridItems.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"BsTreegridItems.vue","sourceRoot":"node_modules/vue-mdbootstrap/src/components/BsGrid","sourcesContent":["<template>\r\n  <tbody>\r\n    <tr\r\n      v-for=\"(item, index) in visibleItems\"\r\n      :key=\"'row-' + index\"\r\n      :class=\"_rowClasses(index)\"\r\n      role=\"row\">\r\n      <slot v-bind=\"{ index: index, item: item.data, level: item.depth, node: item }\">\r\n        <template v-for=\"(column, colIdx) in columns\">\r\n          <component\r\n            :is=\"_componentName(colIdx)\"\r\n            :column=\"column\"\r\n            :index=\"colIdx\"\r\n            :item=\"item.data\"\r\n            :node=\"item\"\r\n            :key=\"column.field + '-' + _uuid()\" />\r\n        </template>\r\n      </slot>\r\n    </tr>\r\n  </tbody>\r\n</template>\r\n\r\n<script>\r\n/**\r\n * TreeNode data type.\r\n *\r\n * @typedef {Object} ITreeNode\r\n * @property {BsModel|Object} data The Node's data model\r\n * @property {number} depth        The Node's depth level in the TreeList\r\n * @property {number} index        The Node's absolute index position in the ArrayList\r\n * @property {ITreeNode} parent    The parent of this Node\r\n * @property {boolean} leaf        The Node's flag, describe it is the last child in the TreeList or not\r\n * @property {boolean} expanded    The Node's state, expanded or collapsed\r\n */\r\nimport BsTreeStore from \"../../model/BsTreeStore\";\r\nimport BsTreegridCell from \"./BsTreegridCell\";\r\nimport BsGridCell from \"./BsGridCell\";\r\nimport Common from \"../../mixins/Common\";\r\nimport Helper from \"../../utils/Helper\";\r\n\r\nexport default {\r\n    name: \"BsTreegridItems\",\r\n    components: {BsTreegridCell, BsGridCell},\r\n    mixins: [Common],\r\n    inject: ['TreeGrid'],\r\n    props: {\r\n        columns: {\r\n            type: Array,\r\n            default: undefined\r\n        },\r\n        items: {\r\n            type: Array,\r\n            default: undefined\r\n        }\r\n    },\r\n    data: () => ({\r\n        childrenFieldmap: '',\r\n        treeNodes: []\r\n    }),\r\n    computed: {\r\n        visibleItems() {\r\n            return this.treeNodes.filter(node => {\r\n                return node.depth === 0 || node.expanded || node.parent.expanded;\r\n            });\r\n        }\r\n    },\r\n    created() {\r\n        this.treeNodes = [];\r\n        this.childrenFieldmap = this.TreeGrid.childrenFieldmap;\r\n    },\r\n    beforeDestroy() {\r\n        this.treeNodes = null;\r\n    },\r\n    methods: {\r\n        /**\r\n         * Get component's name at the given index.\r\n         *\r\n         * @param {int} columnIndex Column index position\r\n         * @returns {string} The component's name\r\n         * @private\r\n         */\r\n        _componentName(columnIndex) {\r\n            return columnIndex === 0 ? 'bs-treegrid-cell' : 'bs-grid-cell';\r\n        },\r\n        /**\r\n         * Get row css class at the given index.\r\n         *\r\n         * @param {int} index Absolute index position\r\n         * @returns {string[]} Css classes\r\n         * @private\r\n         */\r\n        _rowClasses(index) {\r\n            return [\r\n                index % 2 === 0 ? 'md-grid-row' : 'md-grid-row-alt',\r\n            ]\r\n        },\r\n        /**\r\n         * Append childnodes to the treeitems.\r\n         *\r\n         * @param {ITreeNode} parentNode     Parent node\r\n         * @param {BsModel[]|Object[]} datas Collection of data model\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        _appendChild(parentNode, datas) {\r\n            let tmpNodes = [];\r\n\r\n            for (let i = 0; i < this.treeNodes.length; i++) {\r\n                const node = this.treeNodes[i];\r\n                tmpNodes.push(node);\r\n\r\n                if (node === parentNode) {\r\n                    let rowIndex = i + 1;\r\n                    for (const data of datas) {\r\n                        const childNode = this._createNode(data, parentNode, (parentNode.depth + 1), rowIndex, false);\r\n                        tmpNodes.push(childNode);\r\n                        rowIndex++;\r\n                    }\r\n                }\r\n                node.index = i;\r\n            }\r\n\r\n            this.treeNodes = tmpNodes;\r\n        },\r\n        /**\r\n         * Create ITreeNode from the given data model.\r\n         *\r\n         * @param {BsModel|Object} data   Data model\r\n         * @param {ITreeNode} parentNode  Parent node\r\n         * @param {int} depth             Node depth level within the TreeList\r\n         * @param {int} index             Absolute node index position within the TreeList\r\n         * @param {boolean} expanded      The node state\r\n         * @returns {ITreeNode} The treeNode\r\n         * @private\r\n         */\r\n        _createNode(data, parentNode, depth, index, expanded) {\r\n            return {\r\n                data: data,\r\n                depth: depth,\r\n                index: index,\r\n                parent: parentNode,\r\n                leaf: this.hasChildren(data) === false,\r\n                expanded: expanded\r\n            }\r\n        },\r\n        /**\r\n         * Iterate childnodes and put them to the given collection.\r\n         *\r\n         * @param {ITreeNode} parentNode   Parent node whos child will be iterated\r\n         * @param {ITreeNode[]} collection An array collection to store the childnodes\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        _iterateChildNode(parentNode, collection) {\r\n            for (let i = parentNode.index; i < this.treeNodes.length; i++) {\r\n                const node = this.treeNodes[i];\r\n                if (node.parent === parentNode) {\r\n                    collection.push(node);\r\n                    if (this.hasChildren(node.data)) {\r\n                        this._iterateChildNode(node, collection);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * Collapse the given node and fires event <b>collapsed</b>.\r\n         *\r\n         * @param {ITreeNode} node The node to collapse\r\n         * @returns {void}\r\n         */\r\n        collapse(node) {\r\n            let collapsedNodes = [];\r\n\r\n            collapsedNodes.push(node);\r\n            if (this.hasChildren(node.data)) {\r\n                this._iterateChildNode(node, collapsedNodes);\r\n            }\r\n            for (const item of collapsedNodes) {\r\n                item.expanded = false;\r\n            }\r\n\r\n            this.TreeGrid.fireEvent('collapsed', node);\r\n        },\r\n        /**\r\n         * Expand the given node and fires event <b>expanded</b>.\r\n         *\r\n         * @param {ITreeNode} node The node to expand\r\n         * @returns {void}\r\n         */\r\n        expand(node) {\r\n            const children = this.getChildren(node.data);\r\n            const adapter = this.TreeGrid.dataSource;\r\n\r\n            if (this.hasChildren(node.data) && Helper.isEmpty(children) && (adapter instanceof BsTreeStore)) {\r\n                adapter.loadChildren(node.data).then(response => {\r\n                    const responseData = response.data;\r\n\r\n                    // Dirty check, populate nodes if condition has been met\r\n                    if (responseData.hasOwnProperty(adapter._config.dataProperty) && responseData.data.length > 0) {\r\n                        this._appendChild(node, this.getChildren(node.data));\r\n                    }\r\n                }).catch(error => {\r\n                    this.TreeGrid.fireEvent('error', error);\r\n                });\r\n            } else if (Helper.isEmpty(children)) {\r\n                node.leaf = true;\r\n            }\r\n\r\n            if (node.leaf === false) {\r\n                node.expanded = true;\r\n                this.TreeGrid.fireEvent('expanded', node);\r\n            }\r\n        },\r\n        /**\r\n         * Get children of the given data model.\r\n         *\r\n         * @param {BsModel|Object} item Data model\r\n         * @returns {BsModel[]|Object[]} The child items\r\n         */\r\n        getChildren(item) {\r\n            return item[this.childrenFieldmap];\r\n        },\r\n        /**\r\n         * Check if the given data model has one or more child or not.\r\n         *\r\n         * @param {Object} item Data model to check\r\n         * @returns {boolean} TRUE if the given model has child otherwise FALSE\r\n         */\r\n        hasChildren(item) {\r\n            const children = this.getChildren(item);\r\n\r\n            return item.hasChildren === true || item.leaf === false || (Helper.isArray(children) && children.length > 0);\r\n        },\r\n        /**\r\n         * Populate and create list of nodes from the given data sources.\r\n         *\r\n         * @param {int} depth                   Node depth level\r\n         * @param {BsModel[]|Object[]} sources  Collection of data model\r\n         * @param {ITreeNode|*} parentNode      Parent node\r\n         * @returns {void}\r\n         */\r\n        populateNodes(depth, sources, parentNode = null) {\r\n            const expandDepth = this.TreeGrid.expandDepth;\r\n            const expanded = this.TreeGrid.expanded;\r\n            let rowIndex = this.treeNodes.length;\r\n\r\n            for (const source of sources) {\r\n                const node = this._createNode(\r\n                    source, parentNode, depth, rowIndex,\r\n                    (source.expanded === true ? true : (expandDepth > depth ? true : expanded))\r\n                );\r\n\r\n                rowIndex = this.treeNodes.push(node);\r\n                if (this.hasChildren(source)) {\r\n                    this.populateNodes(depth + 1, this.getChildren(source), node);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n\r\n</style>\r\n"]}]}